# ğŸ§­ System Design Patterns Overview

> **Architecture determines reliability, scalability, cost, and latency.**

This document summarizes the **core concepts and foundational patterns** of system design.  
Each section includes a short explanation, visual diagram, and key trade-offs.

---

## ğŸ“¦ Storage

Choosing the right data store for performance, scalability, and cost.

![Storage Diagram](../images/storage.png?raw=true)
*Figure 1 â€“ Data storage strategies and types (SQL, NoSQL, Blob).*

**Key ideas**
- Use **Relational DBs** (PostgreSQL, MySQL) for ACID transactions.  
- Use **NoSQL** (Cassandra, DynamoDB) for horizontal scalability.  
- Use **Object storage** (S3, Blob) for media and static assets.

---

## ğŸ§® Partitioning & Sharding

Splitting data logically or physically to improve scalability and fault isolation.

![Partitioning & Sharding Diagram](images/partitioning-sharding.png)
*Figure 2 â€“ Logical vs physical data distribution.*

**Key ideas**
- Partitioning divides data within a DB (by region, user ID, etc.).  
- Sharding distributes partitions across multiple servers.  
- Helps scale horizontally and contain failures.

---

## â™»ï¸ Redundancy & Replication

Ensuring availability and durability through duplication.

![Redundancy & Replication Diagram](images/redundancy-replication.png)
*Figure 3 â€“ Replication and failover patterns.*

**Key ideas**
- Replicate from primary â†’ read replicas for load distribution.  
- Add redundant servers to eliminate single points of failure.  
- Combine both for fault-tolerant systems.

---

## âš–ï¸ Load Balancing

Distribute user requests evenly across multiple backend servers.

![Load Balancing Diagram](images/load-balancing.png)
*Figure 4 â€“ Round Robin, Least Connections, and IP Hash strategies.*

**Key ideas**
- Use **Round Robin** for simplicity.  
- Use **Least Connections** for dynamic workloads.  
- DNS-level balancing for global routing.

---

## ğŸ§Š Caching

Store frequently accessed data close to users to reduce latency.

![Caching Diagram](images/caching.png)
*Figure 5 â€“ Caching layers and eviction strategies.*

**Key ideas**
- Place caches between app â†” DB.  
- Strategies: LRU, LFU, TTL.  
- Balance freshness vs performance.

---

## ğŸŒ Content Delivery Network (CDN)

Serve static content from edge locations near users.

![CDN Diagram](images/cdn.png)
*Figure 6 â€“ Edge delivery and origin fallback.*

**Key ideas**
- Use CDNs for media, JS/CSS, and images.  
- Reduces latency and server load.  
- Improves availability during spikes.

---

## ğŸš¦ Rate Limiting & Throttling

Protect systems from abuse and traffic spikes.

![Rate Limiting Diagram](images/rate-limiting.png)
*Figure 7 â€“ Token bucket algorithm controlling request flow.*

**Key ideas**
- Smooths bursts while maintaining throughput.  
- Common algorithms: Token Bucket, Leaky Bucket.  
- Implement per API key, IP, or user.

---

## âš™ï¸ Asynchronous Processing

Handle background work off the main thread for better responsiveness.

![Async Processing Diagram](images/async-processing.png)
*Figure 8 â€“ Service â†’ Queue â†’ Workers flow.*

**Key ideas**
- Decouple slow tasks via queues (Kafka, SQS).  
- Enable retries and DLQs.  
- Improves throughput and resilience.

---

## ğŸ§© CAP Theorem

A distributed system cannot simultaneously guarantee all three:  
**Consistency, Availability, Partition tolerance.**

![CAP Theorem Diagram](images/cap-theorem.png)
*Figure 9 â€“ CAP trade-offs (CP vs AP systems).*

**Key ideas**
- **CP:** prefer accuracy, may reject requests.  
- **AP:** prefer uptime, may return stale data.  
- Partition tolerance is mandatory.

---

## ğŸ§  PACELC Theorem

Extends CAP â€” when no partition occurs, systems trade **Latency** vs **Consistency**.

![PACELC Theorem Diagram](images/pacelc.png)
*Figure 10 â€“ Latency vs Consistency under normal conditions.*

**Key ideas**
- During partition â†’ choose between C and A.  
- Else â†’ trade between L and C.  
- Guides modern distributed DB design.

---

## ğŸ“Š Functional vs Non-Functional Requirements

| Type | Examples |
|------|-----------|
| **Functional** | Upload photos, create accounts, generate invoices |
| **Non-Functional** | Latency < 200 ms, 99.9 % uptime, secure authentication |

---

## ğŸ’¡ Takeaways

- Architecture choices drive reliability, scalability, and latency.  
- Every decision is a trade-off â€” thereâ€™s no silver bullet.  
- Scale horizontally early; optimize vertically later.  
- Pick consistency, availability, and latency trade-offs consciously.  

---

> ğŸ§© *Part of April Northcuttâ€™s System Design Series â€” visual, educational patterns for scalable architecture.*
